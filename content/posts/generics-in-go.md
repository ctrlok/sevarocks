+++
title = "Дженерики в Go"
date = "2021-11-13"
+++

Дженерики

Как много в этом слове… 

И “дже”.. и “не”.. и даже “рики”! А Рики это очень важно, потому что рики-тики-тави охранял жилище от коварных змей. 

В гошечке дженерики почти всегда нафиг не нужны (рядовому оболтусу). Но будут. 

Зачем они нужны? Ну вот давайте представим что мы пишем программу. У нас там есть каналы, структуры, интерфейсы, можно грабить корованы... 

Начнём с простого — напишем функцию которая берет два значения Left и Right и возвращает Left

Для двух строк это просто или двух чисел это просто:

```go
func ReturnLeft(left, right string) string {
 return left
}

func ReturnLeftInt(left, right int) int {
 return left
}
```

Но как нам написать функцию которая работает с всеми типами? Можно воспользоваться пустым интерфейсом.

```go
func ReturnLeft(left, right interface{}) interface{} {
 return left
}
```

Но тогда если мы вызовем эту функцию, на выходе мы получим пустой интерфейс и нам прийдется каждый раз угадывать что мы получили обратно. 


А что если нам надо создавать какой-то список или писать в каналы?
Собственно для этого и существуют дженерики. Для работы с данными в целом. 


```go
func ReturnLeft[T any](left, right T) T {
 return left
}
```

Большая часть для чего использовались дженерики и так реализована через интерфейсы. Кроме всего, что не реализовано.

Например, при помощи дженериков можно вернуть N элементов из массива любого типа. 

```go
func ReturnN[T any](list []T, n int) []T {
 return list[:n]
}
```

Короче, это штука которая вам будет нафиг не нужна почти всегда.  Кроме тогда когда нужна. Дженерики позволят делать библиотеки намного удобнее и интуитивнее чем есть сейчас, так что большая победа для Go сообщества. 
Ну и конечно это огромный простор для злоупотреблений. Так что ожидайте большого количества использования дженериков там где они вооооообще не нужны.

{{tg(id="devops_tricks/279")}}